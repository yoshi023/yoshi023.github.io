<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a1a">
    <title>Block Territory - Professional Fix</title>
    <style>
        :root {
            --p1-color: #3498db; --p2-color: #e74c3c; --bg-color: #1a1a1a;
            --preview-ok: rgba(255, 255, 255, 0.5); --preview-ng: rgba(255, 0, 0, 0.4);
            --iron-color: #7f8c8d; --scorch-color: #0d0d0d;
        }

        * { touch-action: none; -webkit-tap-highlight-color: transparent; user-select: none; }

        body {
            margin: 0; padding: 0; background-color: var(--bg-color); color: white;
            font-family: sans-serif; display: flex; justify-content: center; align-items: center;
            height: 100vh; overflow: hidden;
        }

        /* Á∏¶ÁîªÈù¢Ë≠¶Âëä„Ç™„Éº„Éê„Éº„É¨„Ç§ */
        #orientation-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
        }
        .phone-icon {
            width: 40px; height: 70px; border: 3px solid white; border-radius: 5px;
            margin-bottom: 20px; animation: rotatePhone 2s infinite ease-in-out;
        }
        @keyframes rotatePhone {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(-90deg); }
            100% { transform: rotate(-90deg); }
        }

        @media screen and (orientation: portrait) {
            #orientation-overlay { display: flex; }
            #game-container { display: none; }
        }

        #game-container {
            display: flex; flex-direction: row; width: 100vw; height: 100vh;
            padding: 10px; box-sizing: border-box; gap: 10px;
        }

        .player-panel {
            flex: 1; display: flex; flex-direction: column; justify-content: space-around;
            align-items: center; background: #2a2a2a; border-radius: 15px; padding: 10px;
            border: 4px solid transparent; transition: all 0.3s; max-width: 140px;
        }
        .player-panel.active { opacity: 1; filter: none; pointer-events: auto; }
        .player-panel.p1-side.active { border-color: var(--p1-color); box-shadow: 0 0 15px var(--p1-color); }
        .player-panel.p2-side.active { border-color: var(--p2-color); box-shadow: 0 0 15px var(--p2-color); }
        .player-panel:not(.active) { opacity: 0.3; filter: grayscale(0.8); pointer-events: none; }

        #board-container { flex: 3; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 5px; }
        #board {
            display: grid; grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(5, 1fr); gap: 2px;
            background-color: #333; border: 4px solid #444;
            width: 100%; aspect-ratio: 2 / 1; position: relative;
        }

        .cell { background-color: #222; border-radius: 3px; position: relative; }
        .cell.p1 { background-color: var(--p1-color); }
        .cell.p2 { background-color: var(--p2-color); }
        .cell.hard { background: linear-gradient(135deg, #bdc3c7 0%, #7f8c8d 50%, #2c3e50 100%) !important; }
        .cell.valid-preview { background-color: var(--preview-ok) !important; box-shadow: inset 0 0 5px #fff; }
        .cell.invalid-preview { background-color: var(--preview-ng) !important; }
        .cell.scorched { background-color: var(--scorch-color) !important; }
        .cell.bomb-visible::after { content: "üí£"; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 1.1rem; }

        #boom-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; font-weight: bold; color: #ffeb3b; opacity: 0; z-index: 100; pointer-events: none; }
        .boom-anim { animation: boom 0.8s ease-out; }
        @keyframes boom { 0% { opacity:0; transform:translate(-50%,-50%) scale(0.5); } 20% { opacity:1; transform:translate(-50%,-50%) scale(1.2); } 100% { opacity:0; transform:translate(-50%,-50%) scale(1.5); } }

        .next-box { width: 70px; height: 70px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 1px; background: #111; padding: 4px; border-radius: 6px; cursor: grab; }
        .btn-skip { width: 100%; padding: 6px; font-weight: bold; border-radius: 6px; border: none; background: #555; color: white; font-size: 0.7rem; }
        #fs-btn { position: fixed; top: 10px; right: 10px; background: rgba(255,255,255,0.1); border: none; color: white; padding: 5px 10px; border-radius: 5px; font-size: 0.7rem; z-index: 2000; }
        #result-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; flex-direction: column; justify-content: center; align-items: center; }
    </style>
</head>
<body>

<div id="orientation-overlay">
    <div class="phone-icon"></div>
    <p>ÁîªÈù¢„ÇíÊ®™Âêë„Åç„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
</div>

<button id="fs-btn" onclick="toggleFullScreen()">Fullscreen</button>

<div id="result-overlay">
    <h1 id="winner-text">RESULT</h1>
    <div id="result-scores" style="font-size: 1.5rem; margin-bottom: 20px;"></div>
    <button onclick="resetGame()" style="padding:10px 20px;">Rematch</button>
</div>

<div id="game-container">
    <div id="panel-p1" class="player-panel p1-side">
        <h2>P1</h2>
        <div id="score-p1">0</div>
        <div id="next-p1" class="next-box"></div>
        <button class="btn-skip" onclick="skipTurn()">Skip (<span id="pass-p1">3</span>)</button>
    </div>

    <div id="board-container">
        <div id="penalty-text" style="height:1.2em; color:#f1c40f; font-weight:bold;"></div>
        <div id="board"><div id="boom-text">BOOM!</div></div>
        <div id="turn-display" style="font-weight:bold;"></div>
    </div>

    <div id="panel-p2" class="player-panel p2-side">
        <h2>P2</h2>
        <div id="score-p2">0</div>
        <div id="next-p2" class="next-box"></div>
        <button class="btn-skip" onclick="skipTurn()">Skip (<span id="pass-p2">3</span>)</button>
    </div>
</div>

<script>
    const ROWS = 5, COLS = 10;
    let board, currentPlayer, scores, passCount, currentPiece, visibleBombs, hiddenBombs, isWait, isHard;
    let skipPenalty = { 1: false, 2: false };

    const SHAPES = [
        [[1]], [[1,1]], [[1,1,1]], [[1,1],[1,0]],
        [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]],
        [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]]
    ];

    function init() {
        board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        scores = {1: 0, 2: 0}; passCount = {1: 3, 2: 3};
        currentPlayer = 1; isWait = false; skipPenalty = { 1: false, 2: false };
        const b = document.getElementById('board');
        b.innerHTML = '<div id="boom-text">BOOM!</div>';
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell'; cell.id = `cell-${r}-${c}`;
                b.appendChild(cell);
            }
        }
        placeBombs(); setupControls(); spawnPiece(); updateUI();
    }

    function placeBombs() {
        const positions = [];
        while(positions.length < 4) {
            const pos = { r: Math.floor(Math.random()*ROWS), c: Math.floor(Math.random()*COLS) };
            if(!positions.some(p => p.r === pos.r && p.c === pos.c)) positions.push(pos);
        }
        visibleBombs = [positions[0], positions[1]]; hiddenBombs = [positions[2], positions[3]];
        visibleBombs.forEach(b => document.getElementById(`cell-${b.r}-${b.c}`).classList.add('bomb-visible'));
    }

    function setupControls() {
        let isDragging = false;
        let startX, startY;

        const handlePointerDown = (e) => {
            if (isWait) return;
            const targetBox = document.getElementById(`next-p${currentPlayer}`);
            if (targetBox.contains(e.target)) {
                isDragging = true;
                startX = e.clientX; startY = e.clientY;
                e.target.setPointerCapture(e.pointerId);
            }
        };

        const handlePointerMove = (e) => {
            if (!isDragging) return;
            const pos = getBoardPos(e.clientX, e.clientY);
            clearPreview();
            if (pos) showPreview(pos.r, pos.c);
        };

        const handlePointerUp = (e) => {
            if (!isDragging) return;
            const dist = Math.hypot(e.clientX - startX, e.clientY - startY);
            if (dist < 8) {
                rotatePiece();
            } else {
                const pos = getBoardPos(e.clientX, e.clientY);
                if (pos) tryPlace(pos.r, pos.c);
            }
            isDragging = false;
            clearPreview();
        };

        window.onpointerdown = handlePointerDown;
        window.onpointermove = handlePointerMove;
        window.onpointerup = handlePointerUp;
    }

    function getBoardPos(clientX, clientY) {
        const rect = document.getElementById('board').getBoundingClientRect();
        if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
            return {
                r: Math.floor((clientY - rect.top) / (rect.height / ROWS)),
                c: Math.floor((clientX - rect.left) / (rect.width / COLS))
            };
        }
        return null;
    }

    function spawnPiece() {
        currentPiece = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        isHard = Math.random() < 0.15;
        renderNextPiece();
    }

    function rotatePiece() {
        currentPiece = currentPiece[0].map((_, i) => currentPiece.map(row => row[i]).reverse());
        renderNextPiece();
    }

    function showPreview(r, c) {
        const ok = canPlace(r, c, currentPiece);
        currentPiece.forEach((row, ri) => {
            row.forEach((val, ci) => {
                if (val) {
                    const el = document.getElementById(`cell-${r+ri}-${c+ci}`);
                    if (el) el.classList.add(ok ? 'valid-preview' : 'invalid-preview');
                }
            });
        });
    }

    function clearPreview() {
        document.querySelectorAll('.cell').forEach(c => c.classList.remove('valid-preview', 'invalid-preview'));
    }

    function tryPlace(r, c) {
        if (!canPlace(r, c, currentPiece)) return;
        let explodedPos = null;
        
        currentPiece.forEach((row, ri) => {
            row.forEach((val, ci) => {
                if (val) {
                    const tr = r + ri, tc = c + ci;
                    board[tr][tc] = isHard ? "hard" : currentPlayer;
                    scores[currentPlayer]++;
                    document.getElementById(`cell-${tr}-${tc}`).className = `cell ${isHard ? 'hard' : 'p' + currentPlayer}`;
                    
                    [visibleBombs, hiddenBombs].forEach(list => {
                        const idx = list.findIndex(b => b.r === tr && b.c === tc);
                        if(idx !== -1) { explodedPos = {r: tr, c: tc}; list.splice(idx, 1); }
                    });
                }
            });
        });

        if (explodedPos) {
            skipPenalty[currentPlayer] = true;
            triggerExplosion(explodedPos.r, explodedPos.c);
        } else {
            nextTurn();
        }
    }

    function triggerExplosion(er, ec) {
        isWait = true;
        document.getElementById('board').classList.add('shake');
        document.getElementById('boom-text').classList.add('boom-anim');
        
        for (let r = er - 1; r <= er + 1; r++) {
            for (let c = ec - 1; c <= ec + 1; c++) {
                if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    if (board[r][c] !== "hard") {
                        if (typeof board[r][c] === 'number' && board[r][c] !== 0) scores[board[r][c]]--;
                        board[r][c] = 0;
                        setTimeout(() => { 
                            cell.className = 'cell scorched';
                            // 2.5ÁßíÂæå„Å´ÁÑ¶„ÅíË∑°„ÇÇÊ∂à„Åó„ÄÅÂÆåÂÖ®„Å´„É™„Çª„ÉÉ„Éà„Åô„Çã
                            setTimeout(() => { if(board[r][c] === 0) cell.className = 'cell'; }, 2000);
                        }, 500);
                    }
                }
            }
        }
        setTimeout(() => {
            document.getElementById('board').classList.remove('shake');
            document.getElementById('boom-text').classList.remove('boom-anim');
            isWait = false; nextTurn();
        }, 1200);
    }

    function canPlace(r, c, shape) {
        for (let ri = 0; ri < shape.length; ri++) {
            for (let ci = 0; ci < shape[ri].length; ci++) {
                if (shape[ri][ci]) {
                    const tr = r + ri, tc = c + ci;
                    if (tr < 0 || tr >= ROWS || tc < 0 || tc >= COLS || board[tr][tc] !== 0) return false;
                }
            }
        }
        return true;
    }

    function skipTurn() { if (passCount[currentPlayer] > 0) { passCount[currentPlayer]--; nextTurn(); } }

    function nextTurn() {
        let nextPlayer = (currentPlayer === 1) ? 2 : 1;
        if (skipPenalty[nextPlayer]) {
            skipPenalty[nextPlayer] = false;
            document.getElementById('penalty-text').innerText = `P${nextPlayer} STUNNED!`;
        } else {
            document.getElementById('penalty-text').innerText = "";
            currentPlayer = nextPlayer;
        }
        spawnPiece(); updateUI(); checkGameOver();
    }

    function updateUI() {
        document.getElementById('panel-p1').classList.toggle('active', currentPlayer === 1);
        document.getElementById('panel-p2').classList.toggle('active', currentPlayer === 2);
        document.getElementById('score-p1').innerText = scores[1];
        document.getElementById('score-p2').innerText = scores[2];
        document.getElementById('pass-p1').innerText = passCount[1];
        document.getElementById('pass-p2').innerText = passCount[2];
        const td = document.getElementById('turn-display');
        td.innerText = `P${currentPlayer} TURN`;
        td.style.color = currentPlayer === 1 ? 'var(--p1-color)' : 'var(--p2-color)';
    }

    function renderNextPiece() {
        [1, 2].forEach(p => document.getElementById(`next-p${p}`).innerHTML = '');
        const box = document.getElementById(`next-p${currentPlayer}`);
        const color = isHard ? 'var(--iron-color)' : (currentPlayer === 1 ? 'var(--p1-color)' : 'var(--p2-color)');
        for (let i = 0; i < 16; i++) box.appendChild(document.createElement('div')).className = 'mini-cell';
        currentPiece.forEach((row, ri) => {
            row.forEach((val, ci) => {
                if (val) {
                    const target = box.children[ri * 4 + ci];
                    if(target) { target.style.backgroundColor = color; if(isHard) target.classList.add('hard'); }
                }
            });
        });
    }

    function checkGameOver() {
        let canMove = false;
        let tempPiece = JSON.parse(JSON.stringify(currentPiece));
        for (let rot = 0; rot < 4; rot++) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) { if (canPlace(r, c, tempPiece)) { canMove = true; break; } }
                if (canMove) break;
            }
            if (canMove) break;
            tempPiece = tempPiece[0].map((_, i) => tempPiece.map(row => row[i]).reverse());
        }
        if (!canMove && passCount[currentPlayer] === 0) {
            document.getElementById('result-overlay').style.display = 'flex';
            document.getElementById('result-scores').innerText = `P1: ${scores[1]} | P2: ${scores[2]}`;
            document.getElementById('winner-text').innerText = scores[1] > scores[2] ? "P1 WIN!" : "P2 WIN!";
        }
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
    }
    function resetGame() { document.getElementById('result-overlay').style.display = 'none'; init(); }

    init();
</script>
</body>
</html>

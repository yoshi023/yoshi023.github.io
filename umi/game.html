<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a1a">
    <title>Block Territory - Hover Fixed</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">

    <style>
        :root {
            --p1-color: #3498db;
            --p2-color: #e74c3c;
            --bg-color: #1a1a1a;
            --preview-ok: rgba(255, 255, 255, 0.5); /* „Éó„É¨„Éì„É•„ÉºÔºöÁôΩ */
            --preview-ng: rgba(255, 0, 0, 0.4);   /* „Éó„É¨„Éì„É•„ÉºÔºöËµ§ */
            --bomb-color: #f1c40f;
            --scorch-color: #0d0d0d;
            --iron-color: #7f8c8d;
        }

        #orientation-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
        }
        @media screen and (orientation: portrait) {
            #orientation-overlay { display: flex; }
            #game-container { display: none; }
        }

        body {
            margin: 0; padding: 0; background-color: var(--bg-color); color: white;
            font-family: sans-serif; display: flex; 
            justify-content: center; align-items: center; height: 100vh; 
            overflow: hidden; touch-action: none;
        }

        #game-container {
            display: flex; flex-direction: row; align-items: stretch;
            width: 100vw; height: 100vh; padding: 10px; box-sizing: border-box; gap: 10px;
        }

        .player-panel {
            flex: 1; display: flex; flex-direction: column;
            justify-content: space-around; align-items: center;
            background: #2a2a2a; border-radius: 15px; padding: 10px;
            border: 4px solid transparent; transition: all 0.3s; max-width: 140px;
        }
        .player-panel.active { opacity: 1; filter: none; pointer-events: auto; }
        .player-panel.p1-side.active { border-color: var(--p1-color); box-shadow: 0 0 15px var(--p1-color); }
        .player-panel.p2-side.active { border-color: var(--p2-color); box-shadow: 0 0 15px var(--p2-color); }
        .player-panel:not(.active) { opacity: 0.3; filter: grayscale(0.8); pointer-events: none; }

        #board-container { flex: 3; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 5px; }
        #board {
            display: grid; grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(5, 1fr); gap: 2px;
            background-color: #333; border: 4px solid #444;
            width: 100%; aspect-ratio: 2 / 1; position: relative;
        }

        .cell { background-color: #222; border-radius: 3px; position: relative; overflow: hidden; }
        .cell.p1 { background-color: var(--p1-color); }
        .cell.p2 { background-color: var(--p2-color); }
        .cell.hard { background: linear-gradient(135deg, #bdc3c7 0%, #7f8c8d 50%, #2c3e50 100%) !important; }
        
        /* „Éó„É¨„Éì„É•„ÉºË°®Á§∫Áî®„ÅÆ„Çπ„Çø„Ç§„É´ */
        .cell.valid-preview { background-color: var(--preview-ok) !important; box-shadow: inset 0 0 5px #fff; }
        .cell.invalid-preview { background-color: var(--preview-ng) !important; }

        .cell.scorched { background-color: var(--scorch-color) !important; }
        .cell.bomb-visible::after { content: "üí£"; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 1.1rem; }

        #boom-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; font-weight: bold; color: #ffeb3b; opacity: 0; z-index: 100; pointer-events: none;}
        .boom-anim { animation: boom 0.8s ease-out; }
        @keyframes boom { 0% { opacity:0; transform:translate(-50%,-50%) scale(0.5); } 20% { opacity:1; transform:translate(-50%,-50%) scale(1.2); } 100% { opacity:0; transform:translate(-50%,-50%) scale(1.5); } }

        .next-box { width: 70px; height: 70px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 1px; background: #111; padding: 4px; border-radius: 6px; touch-action: none; cursor: grab; }
        .mini-cell { background: transparent; }
        .btn-skip { width: 100%; padding: 6px; font-weight: bold; border-radius: 6px; border: none; background: #555; color: white; font-size: 0.7rem; cursor: pointer; }
        #fs-btn { position: fixed; top: 10px; right: 10px; background: rgba(255,255,255,0.1); border: none; color: white; padding: 5px 10px; border-radius: 5px; font-size: 0.7rem; cursor: pointer; z-index: 2000; }
        #result-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; flex-direction: column; justify-content: center; align-items: center; }
    </style>
</head>
<body>

<button id="fs-btn" onclick="toggleFullScreen()">ÂÖ®ÁîªÈù¢Ë°®Á§∫</button>

<div id="orientation-overlay">
    <p>ÁîªÈù¢„ÇíÊ®™Âêë„Åç„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
</div>

<div id="result-overlay">
    <h1 id="winner-text">RESULT</h1>
    <div id="result-scores" style="font-size: 1.5rem; margin-bottom: 20px;"></div>
    <button onclick="resetGame()">„ÇÇ„ÅÜ„ÅÑ„Å°„Å©</button>
</div>

<div id="game-container">
    <div id="panel-p1" class="player-panel p1-side">
        <h2>P1</h2>
        <div id="score-p1">0</div>
        <div id="next-p1" class="next-box"></div>
        <button class="btn-skip" onclick="skipTurn()">„Éë„Çπ (ÊÆã<span id="pass-p1">3</span>)</button>
    </div>

    <div id="board-container">
        <div id="penalty-text"></div>
        <div id="board"><div id="boom-text">BOOM!</div></div>
        <div id="turn-display"></div>
    </div>

    <div id="panel-p2" class="player-panel p2-side">
        <h2>P2</h2>
        <div id="score-p2">0</div>
        <div id="next-p2" class="next-box"></div>
        <button class="btn-skip" onclick="skipTurn()">„Éë„Çπ (ÊÆã<span id="pass-p2">3</span>)</button>
    </div>
</div>

<script>
    const ROWS = 5, COLS = 10;
    let board, currentPlayer, scores, passCount, currentPiece, visibleBombs, hiddenBombs, isWait, isHard;
    let skipPenalty = { 1: false, 2: false };

    const SHAPES = [
        [[1]], [[1,1]], [[1,1,1]], [[1,1],[1,0]],
        [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]],
        [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]]
    ];

    function init() {
        board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        scores = {1: 0, 2: 0}; passCount = {1: 3, 2: 3};
        currentPlayer = 1; isWait = false; skipPenalty = { 1: false, 2: false };
        const b = document.getElementById('board');
        b.innerHTML = '<div id="boom-text">BOOM!</div>';
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell'; cell.id = `cell-${r}-${c}`;
                b.appendChild(cell);
            }
        }
        placeBombs(); setupGlobalControls(); spawnPiece(); updateUI();
    }

    function placeBombs() {
        const positions = [];
        while(positions.length < 4) {
            const pos = { r: Math.floor(Math.random()*ROWS), c: Math.floor(Math.random()*COLS) };
            if(!positions.some(p => p.r === pos.r && p.c === pos.c)) positions.push(pos);
        }
        visibleBombs = [positions[0], positions[1]]; hiddenBombs = [positions[2], positions[3]];
        visibleBombs.forEach(b => document.getElementById(`cell-${b.r}-${b.c}`).classList.add('bomb-visible'));
    }

    // Êìç‰Ωú„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÊîπÂñÑ
    function setupGlobalControls() {
        let isDragging = false;
        let startX, startY;

        const handleStart = (e) => {
            if (isWait) return;
            const targetBox = document.getElementById(`next-p${currentPlayer}`);
            if (targetBox.contains(e.target)) {
                isDragging = true;
                startX = e.clientX || e.touches[0].clientX;
                startY = e.clientY || e.touches[0].clientY;
            }
        };

        const handleMove = (e) => {
            if (!isDragging) return;
            const clientX = e.clientX || (e.touches ? e.touches[0].clientX : null);
            const clientY = e.clientY || (e.touches ? e.touches[0].clientY : null);
            
            const pos = getBoardPos(clientX, clientY);
            clearPreview();
            if (pos) {
                showPreview(pos.r, pos.c);
            }
        };

        const handleEnd = (e) => {
            if (!isDragging) return;
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            
            const dist = Math.hypot(clientX - startX, clientY - startY);
            if (dist < 15) {
                rotatePiece();
            } else {
                const pos = getBoardPos(clientX, clientY);
                if (pos) tryPlace(pos.r, pos.c);
            }
            isDragging = false;
            clearPreview();
        };

        window.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchstart', handleStart, {passive:false});
        window.addEventListener('touchmove', handleMove, {passive:false});
        window.addEventListener('touchend', handleEnd, {passive:false});
    }

    function getBoardPos(clientX, clientY) {
        const rect = document.getElementById('board').getBoundingClientRect();
        if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
            return {
                r: Math.floor((clientY - rect.top) / (rect.height / ROWS)),
                c: Math.floor((clientX - rect.left) / (rect.width / COLS))
            };
        }
        return null;
    }

    function spawnPiece() {
        currentPiece = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        isHard = Math.random() < 0.15;
        renderNextPiece();
    }

    function rotatePiece() {
        currentPiece = currentPiece[0].map((_, i) => currentPiece.map(row => row[i]).reverse());
        renderNextPiece();
    }

    function showPreview(r, c) {
        const ok = canPlace(r, c, currentPiece);
        currentPiece.forEach((row, ri) => {
            row.forEach((val, ci) => {
                if (val) {
                    const el = document.getElementById(`cell-${r+ri}-${c+ci}`);
                    if (el) el.classList.add(ok ? 'valid-preview' : 'invalid-preview');
                }
            });
        });
    }

    function clearPreview() {
        document.querySelectorAll('.cell').forEach(c => c.classList.remove('valid-preview', 'invalid-preview'));
    }

    function tryPlace(r, c) {
        if (!canPlace(r, c, currentPiece)) return;
        let explodedPos = null;
        currentPiece.forEach((row, ri) => {
            row.forEach((val, ci) => {
                if (val) {
                    const tr = r + ri, tc = c + ci;
                    board[tr][tc] = isHard ? "hard" : currentPlayer;
                    scores[currentPlayer]++;
                    document.getElementById(`cell-${tr}-${tc}`).className = `cell ${isHard ? 'hard' : 'p' + currentPlayer}`;
                    [visibleBombs, hiddenBombs].forEach(list => {
                        const idx = list.findIndex(b => b.r === tr && b.c === tc);
                        if(idx !== -1) { explodedPos = {r: tr, c: tc}; list.splice(idx, 1); }
                    });
                }
            });
        });
        if (explodedPos) { skipPenalty[currentPlayer] = true; triggerExplosion(explodedPos.r, explodedPos.c); }
        else { nextTurn(); }
    }

    function triggerExplosion(er, ec) {
        isWait = true;
        document.getElementById('board').classList.add('shake');
        document.getElementById('boom-text').classList.add('boom-anim');
        for (let r = er - 1; r <= er + 1; r++) {
            for (let c = ec - 1; c <= ec + 1; c++) {
                if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    if (board[r][c] !== "hard") {
                        if (board[r][c] !== 0 && typeof board[r][c] === 'number') scores[board[r][c]]--;
                        board[r][c] = 0;
                        setTimeout(() => { cell.className = 'cell scorched'; }, 500);
                    }
                }
            }
        }
        setTimeout(() => {
            document.getElementById('board').classList.remove('shake');
            document.getElementById('boom-text').classList.remove('boom-anim');
            isWait = false; nextTurn();
        }, 1200);
    }

    function canPlace(r, c, shape) {
        for (let ri = 0; ri < shape.length; ri++) {
            for (let ci = 0; ci < shape[ri].length; ci++) {
                if (shape[ri][ci]) {
                    const tr = r + ri, tc = c + ci;
                    if (tr < 0 || tr >= ROWS || tc < 0 || tc >= COLS || board[tr][tc] !== 0) return false;
                }
            }
        }
        return true;
    }

    function skipTurn() { if (passCount[currentPlayer] > 0) { passCount[currentPlayer]--; nextTurn(); } }

    function nextTurn() {
        let nextPlayer = (currentPlayer === 1) ? 2 : 1;
        if (skipPenalty[nextPlayer]) {
            skipPenalty[nextPlayer] = false;
            document.getElementById('penalty-text').innerText = `P${nextPlayer}‰ºë„ÅøÔºÅP${currentPlayer}„ÅÆÈÄ£Á∂öÊâãÁï™`;
        } else {
            document.getElementById('penalty-text').innerText = "";
            currentPlayer = nextPlayer;
        }
        spawnPiece(); updateUI(); checkGameOver();
    }

    function updateUI() {
        document.getElementById('panel-p1').classList.toggle('active', currentPlayer === 1);
        document.getElementById('panel-p2').classList.toggle('active', currentPlayer === 2);
        document.getElementById('score-p1').innerText = scores[1];
        document.getElementById('score-p2').innerText = scores[2];
        document.getElementById('pass-p1').innerText = passCount[1];
        document.getElementById('pass-p2').innerText = passCount[2];
        const td = document.getElementById('turn-display');
        td.innerText = `P${currentPlayer}„ÅÆÁï™`;
        td.style.color = currentPlayer === 1 ? 'var(--p1-color)' : 'var(--p2-color)';
    }

    function renderNextPiece() {
        const boxes = [document.getElementById('next-p1'), document.getElementById('next-p2')];
        boxes.forEach(b => b.innerHTML = '');
        const box = document.getElementById(`next-p${currentPlayer}`);
        const color = isHard ? 'var(--iron-color)' : (currentPlayer === 1 ? 'var(--p1-color)' : 'var(--p2-color)');
        for (let i = 0; i < 16; i++) box.appendChild(document.createElement('div')).className = 'mini-cell';
        currentPiece.forEach((row, ri) => {
            row.forEach((val, ci) => {
                if (val) {
                    const target = box.children[ri * 4 + ci];
                    if(target) { target.style.backgroundColor = color; if(isHard) target.classList.add('hard'); }
                }
            });
        });
    }

    function checkGameOver() {
        let canMove = false;
        let tempPiece = JSON.parse(JSON.stringify(currentPiece));
        for (let rot = 0; rot < 4; rot++) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) { if (canPlace(r, c, tempPiece)) { canMove = true; break; } }
                if (canMove) break;
            }
            if (canMove) break;
            tempPiece = tempPiece[0].map((_, i) => tempPiece.map(row => row[i]).reverse());
        }
        if (!canMove && passCount[currentPlayer] === 0) {
            document.getElementById('result-overlay').style.display = 'flex';
            document.getElementById('result-scores').innerText = `P1: ${scores[1]} | P2: ${scores[2]}`;
            document.getElementById('winner-text').innerText = scores[1] > scores[2] ? "P1 WIN!" : "P2 WIN!";
        }
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
    }
    function resetGame() { document.getElementById('result-overlay').style.display = 'none'; init(); }

    init();
</script>
</body>
</html>

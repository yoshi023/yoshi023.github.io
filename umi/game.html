<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Territory - Scorched Earth Edition</title>
    <style>
        :root {
            --p1-color: #3498db;
            --p2-color: #e74c3c;
            --bg-color: #1a1a1a;
            --preview-ok: rgba(255, 255, 255, 0.4);
            --preview-ng: rgba(255, 0, 0, 0.3);
            --bomb-color: #f1c40f;
            --scorch-color: #0d0d0d; /* ÁÑ¶„Åí„ÅüËâ≤ */
        }

        body {
            margin: 0; padding: 0; background-color: var(--bg-color); color: white;
            font-family: sans-serif; display: flex; 
            justify-content: center; align-items: center; height: 100vh; 
            overflow: hidden; touch-action: none;
        }

        #game-container {
            display: flex; flex-direction: row; align-items: stretch;
            width: 100vw; height: 100vh; padding: 10px; box-sizing: border-box; gap: 10px;
        }

        .player-panel {
            flex: 1; display: flex; flex-direction: column;
            justify-content: space-around; align-items: center;
            background: #2a2a2a; border-radius: 15px; padding: 15px;
            border: 4px solid transparent; transition: all 0.3s; max-width: 180px;
        }
        .player-panel.p1-side.active { border-color: var(--p1-color); box-shadow: 0 0 15px var(--p1-color); }
        .player-panel.p2-side.active { border-color: var(--p2-color); box-shadow: 0 0 15px var(--p2-color); }
        .player-panel:not(.active) { opacity: 0.4; filter: grayscale(0.6); pointer-events: none; }

        #board-container { flex: 3; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 10px; }
        #board {
            display: grid; grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat( ROWS_PLACEHOLDER, 1fr); gap: 3px;
            background-color: #333; border: 4px solid #444;
            width: 100%; aspect-ratio: 2 / 1; position: relative;
        }

        .cell { background-color: #222; border-radius: 4px; pointer-events: none; position: relative; overflow: hidden; transition: background-color 0.5s; }
        .cell.p1 { background-color: var(--p1-color); box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
        .cell.p2 { background-color: var(--p2-color); box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
        
        /* ÁÑ¶„ÅíË∑°„ÅÆË°®Áèæ */
        .cell.scorched {
            background-color: var(--scorch-color) !important;
            background-image: radial-gradient(circle, #333 1px, transparent 1px);
            background-size: 4px 4px;
            box-shadow: inset 0 0 15px #000;
        }

        .cell.valid-preview { background-color: var(--preview-ok) !important; }
        .cell.invalid-preview { background-color: var(--preview-ng) !important; }
        .cell.bomb-visible::after { content: "üí£"; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 1.2rem; z-index: 5; }

        /* ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà */
        @keyframes explosion-flash-anim {
            0% { background-color: #fff; transform: scale(1); opacity: 1; }
            30% { background-color: #ff9800; transform: scale(1.3); }
            100% { background-color: var(--scorch-color); transform: scale(1); opacity: 1; }
        }
        .explosion-fx {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; animation: explosion-flash-anim 0.8s forwards;
        }

        @keyframes shake {
            0%, 100% { transform: translate(0,0); }
            20% { transform: translate(-8px, 5px); }
            40% { transform: translate(8px, -5px); }
            60% { transform: translate(-8px, -5px); }
            80% { transform: translate(8px, 5px); }
        }
        .shake { animation: shake 0.4s ease-in-out; }

        #boom-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 4rem; font-weight: bold; color: #ffeb3b; text-shadow: 0 0 20px #f44336;
            pointer-events: none; opacity: 0; z-index: 100;
        }
        .boom-anim { animation: boom 0.8s ease-out; }
        @keyframes boom { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); } }

        .next-box { width: 80px; height: 80px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px; background: #111; padding: 8px; border-radius: 10px; cursor: pointer; touch-action: none; }
        .mini-cell { background: transparent; }
        .btn-skip { width: 100%; padding: 10px; font-weight: bold; border-radius: 8px; border: none; background: #555; color: white; cursor: pointer; }

        #result-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; flex-direction: column; justify-content: center; align-items: center; }
    </style>
</head>
<body>

<div id="result-overlay">
    <h1 id="winner-text">RESULT</h1>
    <div id="result-scores" style="font-size: 1.5rem; margin-bottom: 20px;"></div>
    <button style="background: #3498db; color:white; width: 200px; padding: 15px; border-radius:10px; border:none;" onclick="resetGame()">„ÇÇ„ÅÜ„ÅÑ„Å°„Å©</button>
</div>

<div id="game-container">
    <div id="panel-p1" class="player-panel p1-side">
        <h2 style="color: var(--p1-color); margin:0;">P1</h2>
        <div id="score-p1" style="font-size: 1.2rem;">0</div>
        <div id="next-p1" class="next-box"></div>
        <button id="skip-p1" class="btn-skip" onclick="skipTurn()">„Éë„Çπ (ÊÆã<span id="pass-p1">3</span>)</button>
    </div>

    <div id="board-container">
        <div id="penalty-text" style="font-size: 1rem; color: #f1c40f; font-weight: bold; height: 1.5em; text-align:center;"></div>
        <div id="board">
            <div id="boom-text">BOOM!</div>
        </div>
        <div id="turn-display" style="font-size: 1.2rem; font-weight: bold;"></div>
    </div>

    <div id="panel-p2" class="player-panel p2-side">
        <h2 style="color: var(--p2-color); margin:0;">P2</h2>
        <div id="score-p2" style="font-size: 1.2rem;">0</div>
        <div id="next-p2" class="next-box"></div>
        <button id="skip-p2" class="btn-skip" onclick="skipTurn()">„Éë„Çπ (ÊÆã<span id="pass-p2">3</span>)</button>
    </div>
</div>

<script>
    const ROWS = 5, COLS = 10;
    let board, currentPlayer, scores, passCount, currentPiece, visibleBombs, hiddenBombs, isWait;
    let skipPenalty = { 1: false, 2: false };

    const SHAPES = [
        [[1]], [[1,1]], [[1,1,1]], [[1,1],[1,0]],
        [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]],
        [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]]
    ];

    function init() {
        board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        scores = {1: 0, 2: 0};
        passCount = {1: 3, 2: 3};
        currentPlayer = 1;
        isWait = false;
        skipPenalty = { 1: false, 2: false };
        
        const boardEl = document.getElementById('board');
        boardEl.style.gridTemplateRows = `repeat(${ROWS}, 1fr)`;
        boardEl.innerHTML = '<div id="boom-text">BOOM!</div>';

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${r}-${c}`;
                boardEl.appendChild(cell);
            }
        }
        
        placeBombs();
        setupControls(1);
        setupControls(2);
        spawnPiece();
        updateUI();
    }

    function placeBombs() {
        const positions = [];
        while(positions.length < 4) {
            const pos = { r: Math.floor(Math.random()*ROWS), c: Math.floor(Math.random()*COLS) };
            if(!positions.some(p => p.r === pos.r && p.c === pos.c)) positions.push(pos);
        }
        visibleBombs = [positions[0], positions[1]];
        hiddenBombs = [positions[2], positions[3]];
        visibleBombs.forEach(b => document.getElementById(`cell-${b.r}-${b.c}`).classList.add('bomb-visible'));
    }

    function setupControls(pNum) {
        const nextBox = document.getElementById(`next-p${pNum}`);
        let startX, startY, isDragging = false;

        nextBox.onpointerdown = (e) => {
            if (isWait || currentPlayer !== pNum) return;
            isDragging = true; startX = e.clientX; startY = e.clientY;
            nextBox.setPointerCapture(e.pointerId);
        };

        window.addEventListener('pointermove', (e) => {
            if (!isDragging) return;
            const pos = getBoardPos(e);
            clearPreview();
            if (pos) showPreview(pos.r, pos.c);
        });

        window.addEventListener('pointerup', (e) => {
            if (!isDragging) return;
            const dist = Math.hypot(e.clientX - startX, e.clientY - startY);
            if (dist < 15) rotatePiece();
            else {
                const pos = getBoardPos(e);
                if (pos) tryPlace(pos.r, pos.c);
            }
            isDragging = false;
            clearPreview();
        });
    }

    function getBoardPos(e) {
        const rect = document.getElementById('board').getBoundingClientRect();
        if (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {
            return {
                r: Math.floor((e.clientY - rect.top) / (rect.height / ROWS)),
                c: Math.floor((e.clientX - rect.left) / (rect.width / COLS))
            };
        }
        return null;
    }

    function spawnPiece() {
        currentPiece = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        renderNextPiece();
    }

    function rotatePiece() {
        currentPiece = currentPiece[0].map((_, i) => currentPiece.map(row => row[i]).reverse());
        renderNextPiece();
    }

    function tryPlace(r, c) {
        if (!canPlace(r, c, currentPiece)) return;

        let explodedPos = null;
        currentPiece.forEach((row, ri) => {
            row.forEach((val, ci) => {
                if (val) {
                    const tr = r + ri, tc = c + ci;
                    board[tr][tc] = currentPlayer;
                    scores[currentPlayer]++;
                    document.getElementById(`cell-${tr}-${tc}`).className = `cell p${currentPlayer}`;
                    
                    [visibleBombs, hiddenBombs].forEach(list => {
                        const idx = list.findIndex(b => b.r === tr && b.c === tc);
                        if(idx !== -1) { explodedPos = {r: tr, c: tc}; list.splice(idx, 1); }
                    });
                }
            });
        });

        if (explodedPos) {
            skipPenalty[currentPlayer] = true;
            triggerExplosion(explodedPos.r, explodedPos.c);
        } else {
            nextTurn();
        }
    }

    function triggerExplosion(er, ec) {
        isWait = true;
        const boardEl = document.getElementById('board');
        const boomText = document.getElementById('boom-text');

        boardEl.classList.add('shake');
        boomText.classList.add('boom-anim');

        for (let r = er - 1; r <= er + 1; r++) {
            for (let c = ec - 1; c <= ec + 1; c++) {
                if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    const owner = board[r][c];
                    
                    // „Ç®„Éï„Çß„ÇØ„ÉàÁîüÊàê
                    const fx = document.createElement('div');
                    fx.className = 'explosion-fx';
                    cell.appendChild(fx);

                    if (owner !== 0) {
                        scores[owner]--;
                        board[r][c] = 0;
                    }

                    // 0.8ÁßíÂæå„Å´ÁÑ¶„ÅíË∑°„ÇØ„É©„Çπ„Çí‰ªò‰∏é„Åó„ÄÅ„Åï„Çâ„Å´3ÁßíÂæå„Å´ÁÑ¶„ÅíË∑°„ÇíÊ∂à„Åô
                    setTimeout(() => {
                        cell.innerHTML = '';
                        cell.className = 'cell scorched';
                        setTimeout(() => {
                            if (board[r][c] === 0) cell.className = 'cell';
                        }, 3000);
                    }, 800);
                }
            }
        }

        setTimeout(() => {
            boardEl.classList.remove('shake');
            boomText.classList.remove('boom-anim');
            isWait = false;
            nextTurn(); 
        }, 1200);
    }

    function skipTurn() {
        if (passCount[currentPlayer] > 0) {
            passCount[currentPlayer]--;
            nextTurn();
        }
    }

    function nextTurn() {
        let nextPlayer = (currentPlayer === 1) ? 2 : 1;
        if (skipPenalty[nextPlayer]) {
            skipPenalty[nextPlayer] = false;
            document.getElementById('penalty-text').innerText = `P${nextPlayer} ‰ºë„Åø„ÅÆÈñì„ÄÅP${currentPlayer} „ÅÆÈÄ£Á∂öÊîªÊíÉÔºÅ`;
        } else {
            document.getElementById('penalty-text').innerText = "";
            currentPlayer = nextPlayer;
        }
        spawnPiece();
        updateUI();
        checkGameOver();
    }

    function checkGameOver() {
        const isFull = board.every(row => row.every(cell => cell !== 0));
        let canMove = false;
        let tempPiece = JSON.parse(JSON.stringify(currentPiece));
        for (let rot = 0; rot < 4; rot++) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (canPlace(r, c, tempPiece)) { canMove = true; break; }
                }
                if (canMove) break;
            }
            if (canMove) break;
            tempPiece = tempPiece[0].map((_, i) => tempPiece.map(row => row[i]).reverse());
        }
        if (isFull || (!canMove && passCount[currentPlayer] === 0)) showResult();
    }

    function canPlace(r, c, shape) {
        for (let ri = 0; ri < shape.length; ri++) {
            for (let ci = 0; ci < shape[ri].length; ci++) {
                if (shape[ri][ci]) {
                    const tr = r + ri, tc = c + ci;
                    if (tr < 0 || tr >= ROWS || tc < 0 || tc >= COLS || board[tr][tc] !== 0) return false;
                }
            }
        }
        return true;
    }

    function updateUI() {
        document.getElementById('panel-p1').className = `player-panel p1-side ${currentPlayer === 1 ? 'active' : ''}`;
        document.getElementById('panel-p2').className = `player-panel p2-side ${currentPlayer === 2 ? 'active' : ''}`;
        document.getElementById('score-p1').innerText = scores[1];
        document.getElementById('score-p2').innerText = scores[2];
        document.getElementById('pass-p1').innerText = passCount[1];
        document.getElementById('pass-p2').innerText = passCount[2];
        const turnDisplay = document.getElementById('turn-display');
        turnDisplay.innerText = `P${currentPlayer}„ÅÆÁï™`;
        turnDisplay.style.color = currentPlayer === 1 ? 'var(--p1-color)' : 'var(--p2-color)';
    }

    function renderNextPiece() {
        document.getElementById('next-p1').innerHTML = '';
        document.getElementById('next-p2').innerHTML = '';
        const box = document.getElementById(`next-p${currentPlayer}`);
        box.innerHTML = '';
        const color = currentPlayer === 1 ? 'var(--p1-color)' : 'var(--p2-color)';
        for (let i = 0; i < 16; i++) box.appendChild(document.createElement('div')).className = 'mini-cell';
        currentPiece.forEach((row, ri) => {
            row.forEach((val, ci) => {
                if (val) {
                    const target = box.children[ri * 4 + ci];
                    if(target) target.style.backgroundColor = color;
                }
            });
        });
    }

    function showResult() {
        const overlay = document.getElementById('result-overlay');
        overlay.style.display = 'flex';
        document.getElementById('result-scores').innerText = `P1: ${scores[1]} | P2: ${scores[2]}`;
        const winTxt = document.getElementById('winner-text');
        winTxt.innerText = scores[1] > scores[2] ? "P1 WIN!" : scores[1] < scores[2] ? "P2 WIN!" : "DRAW";
    }

    function resetGame() { document.getElementById('result-overlay').style.display = 'none'; init(); }
    function clearPreview() { document.querySelectorAll('.cell').forEach(e => e.classList.remove('valid-preview', 'invalid-preview')); }
    function showPreview(r, c) {
        const ok = canPlace(r, c, currentPiece);
        currentPiece.forEach((row, ri) => {
            row.forEach((val, ci) => {
                const el = document.getElementById(`cell-${r+ri}-${c+ci}`);
                if (el && val) el.classList.add(ok ? 'valid-preview' : 'invalid-preview');
            });
        });
    }

    init();
</script>
</body>
</html>

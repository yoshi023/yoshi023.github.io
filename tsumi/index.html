<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>つみゲーム - Stable & Retry Fixed</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #333; font-family: sans-serif; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        
        #score-box { position: absolute; top: 20px; left: 20px; font-size: 20px; font-weight: bold; background: #fff; padding: 10px; border-radius: 8px; border: 2px solid #000; }
        
        #preview-container {
            position: absolute; top: 20px; right: 20px; width: 90px; height: 90px;
            background: #fff; border: 4px solid #3498db; border-radius: 12px;
            pointer-events: auto; cursor: pointer; overflow: hidden;
            box-shadow: 0 4px 0 #2980b9;
        }

        /* 文字はボタンの邪魔をしないように pointer-events: none に設定 */
        #msg { 
            position: absolute; top: 40%; width: 100%; text-align: center; 
            font-size: 40px; color: #ff3e3e; font-weight: bold; 
            display: none; background: rgba(255,255,255,0.8); padding: 15px 0;
            pointer-events: none; 
            z-index: 150;
        }

        /* ボタンを最前面（z-index: 200）にする */
        #retry-btn { 
            position: absolute; top: 60%; left: 50%; transform: translateX(-50%); 
            padding: 15px 30px; background: #3498db; color: #fff; 
            border: none; border-radius: 8px; cursor: pointer; 
            display: none; pointer-events: auto; 
            font-size: 20px; font-weight: bold;
            box-shadow: 0 5px 0 #2980b9;
            z-index: 200; 
        }
        #retry-btn:active { transform: translate(-50%, 2px); box-shadow: 0 3px 0 #2980b9; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="score-box">SCORE: <span id="scoreVal">0</span></div>
    <div id="preview-container"></div>
    <div id="msg">GAME OVER</div>
    <button id="retry-btn">もう一度あそぶ</button>
</div>

<script>
const { Engine, Render, Runner, Bodies, Composite, Body, Events } = Matter;

const width = window.innerWidth;
const height = window.innerHeight;
const engine = Engine.create();

const render = Render.create({
    element: document.body, engine: engine,
    options: { width, height, wireframes: false, background: '#f0f0f0' }
});

const previewEngine = Engine.create();
previewEngine.gravity.y = 0;
const previewRender = Render.create({
    element: document.getElementById('preview-container'),
    engine: previewEngine,
    options: { width: 90, height: 90, wireframes: false, background: '#fff' }
});

const sizes = [
    { w: 40, h: 40, pts: 30, color: '#ff6b6b', img: 'block_s.png' },
    { w: 70, h: 50, pts: 20, color: '#feca57', img: 'block_m.png' },
    { w: 100, h: 60, pts: 10, color: '#48dbfb', img: 'block_l.png' }
];

let score = 0, currentObj = null, previewObj = null, currentRotation = 0;
let isDragging = false, hasMoved = false, isGameOver = false;
let startX = 0, startY = 0, isTouchedInBox = false, lastRotateTime = 0;

Composite.add(engine.world, Bodies.rectangle(width/2, height - 60, 220, 25, { isStatic: true, render: { fillStyle: '#222' } }));

function spawn() {
    if (isGameOver) return;
    const type = sizes[Math.floor(Math.random() * sizes.length)];
    hasMoved = false;
    currentRotation = 0;

    if (previewObj) Composite.remove(previewEngine.world, previewObj);
    previewObj = Bodies.rectangle(45, 45, type.w * 0.7, type.h * 0.7, {
        isStatic: true, render: { fillStyle: type.color, sprite: { texture: type.img } }
    });
    Composite.add(previewEngine.world, previewObj);

    currentObj = Bodies.rectangle(width / 2, 160, type.w, type.h, {
        isStatic: true, render: { opacity: 0, fillStyle: type.color, sprite: { texture: type.img } },
        friction: 0.5
    });
    currentObj.scoreValue = type.pts;
    Composite.add(engine.world, currentObj);
}

function rotate() {
    const now = Date.now();
    if (now - lastRotateTime < 250) return;
    lastRotateTime = now;
    if (isGameOver || !currentObj || hasMoved) return;
    currentRotation += Math.PI / 2;
    Body.setAngle(currentObj, currentRotation);
    Body.setAngle(previewObj, currentRotation);
}

const inputStart = (x, y) => {
    if (isGameOver || !currentObj) return;
    const box = document.getElementById('preview-container').getBoundingClientRect();
    isTouchedInBox = (x > box.left && x < box.right && y > box.top && y < box.bottom);
    isDragging = true;
    startX = x; startY = y;
};

const inputMove = (x, y) => {
    if (!isDragging || !currentObj || isGameOver) return;
    const dist = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
    if (dist > 10 || hasMoved) {
        hasMoved = true;
        currentObj.render.opacity = 1;
        if (previewObj) previewObj.render.opacity = 0;
        Body.setPosition(currentObj, { x: Math.max(20, Math.min(width - 20, x)), y: 160 });
    }
};

const inputEnd = (e) => {
    if (!isDragging || !currentObj || isGameOver) {
        isDragging = false;
        return;
    }
    if (!hasMoved && isTouchedInBox) {
        rotate();
    } else if (hasMoved) {
        Body.setStatic(currentObj, false);
        score += currentObj.scoreValue;
        document.getElementById('scoreVal').innerText = score;
        currentObj = null;
        setTimeout(spawn, 1000);
    }
    isDragging = false;
    hasMoved = false;
};

// リトライボタンのクリックイベント
document.getElementById('retry-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    location.reload();
});

// スマホのタップにも対応
document.getElementById('retry-btn').addEventListener('touchstart', (e) => {
    e.stopPropagation();
    location.reload();
});

window.addEventListener('mousedown', e => inputStart(e.clientX, e.clientY));
window.addEventListener('mousemove', e => inputMove(e.clientX, e.clientY));
window.addEventListener('mouseup', e => inputEnd(e));

window.addEventListener('touchstart', e => {
    // ボタンをクリックした時はゲームのドラッグ処理を開始しない
    if (e.target.id === 'retry-btn') return;
    inputStart(e.touches[0].clientX, e.touches[0].clientY);
}, {passive: false});

window.addEventListener('touchmove', e => {
    inputMove(e.touches[0].clientX, e.touches[0].clientY);
}, {passive: false});

window.addEventListener('touchend', e => {
    inputEnd(e);
}, {passive: false});

Events.on(engine, 'afterUpdate', () => {
    Composite.allBodies(engine.world).forEach(body => {
        if (!body.isStatic && body.position.y > height) {
            isGameOver = true;
            document.getElementById('msg').style.display = 'block';
            document.getElementById('retry-btn').style.display = 'block';
        }
    });
});

Render.run(render);
Render.run(previewRender);
Runner.run(Runner.create(), engine);
spawn();
</script>
</body>
</html>

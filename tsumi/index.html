<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>つみゲーム - Prototype v9</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #f0f0f0; font-family: sans-serif; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #score-box { position: absolute; top: 20px; left: 20px; font-size: 22px; font-weight: bold; background: #fff; padding: 8px 15px; border-radius: 10px; border: 2px solid #333; }

        #preview-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
            background: #fff;
            border: 4px solid #3498db;
            border-radius: 15px;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 5px 0 #2980b9;
            overflow: hidden;
        }
        #preview-container:active { transform: translateY(2px); box-shadow: 0 3px 0 #2980b9; }
        .label { position: absolute; top: -25px; width: 100%; text-align: center; font-size: 12px; font-weight: bold; color: #3498db; }
        
        #msg { position: absolute; top: 50%; width: 100%; text-align: center; font-size: 40px; color: #e74c3c; font-weight: bold; pointer-events: none; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="score-box">SCORE: <span id="scoreVal">0</span></div>
    <div id="preview-container">
        <div class="label">NEXT (TAP TO ROTATE)</div>
    </div>
    <div id="msg"></div>
</div>

<script>
const { Engine, Render, Runner, Bodies, Composite, Body, Events } = Matter;

const width = window.innerWidth;
const height = window.innerHeight;

const engine = Engine.create();
const render = Render.create({
    element: document.body,
    engine: engine,
    options: { width, height, wireframes: false, background: '#f8f8f8' }
});

const previewEngine = Engine.create();
previewEngine.gravity.y = 0;
const previewRender = Render.create({
    element: document.getElementById('preview-container'),
    engine: previewEngine,
    options: { width: 100, height: 100, wireframes: false, background: '#fff' }
});

const DROP_Y_LINE = 180;
let score = 0;
let currentObj = null;
let previewObj = null;
let currentRotation = 0;
let isGameOver = false;
let isDragging = false;
let hasMovedOut = false;

// タップ判定用の変数
let startX = 0;
let startY = 0;
const DRAG_THRESHOLD = 10; // 10px以上動いたらドラッグとみなす

const sizes = [
    { w: 30, h: 30, color: '#ff6b6b', pts: 30 },
    { w: 60, h: 40, color: '#feca57', pts: 20 },
    { w: 85, h: 45, color: '#48dbfb', pts: 10 }
];

const ground = Bodies.rectangle(width / 2, height - 60, 220, 20, { 
    isStatic: true, render: { fillStyle: '#2c3e50' } 
});
Composite.add(engine.world, ground);

function spawnNext() {
    if (isGameOver) return;
    const nextType = sizes[Math.floor(Math.random() * sizes.length)];
    currentRotation = 0;
    hasMovedOut = false;

    if (previewObj) Composite.remove(previewEngine.world, previewObj);
    previewObj = Bodies.rectangle(50, 50, nextType.w, nextType.h, {
        isStatic: true,
        render: { fillStyle: nextType.color }
    });
    Composite.add(previewEngine.world, previewObj);

    currentObj = Bodies.rectangle(-500, -500, nextType.w, nextType.h, {
        isStatic: true,
        render: { fillStyle: nextType.color, opacity: 0 },
        friction: 0.8
    });
    currentObj.scoreValue = nextType.pts;
    Composite.add(engine.world, currentObj);
}

function handleStart(x, y) {
    if (!currentObj || isGameOver) return;
    const box = document.getElementById('preview-container').getBoundingClientRect();
    if (x > box.left && x < box.right && y > box.top && y < box.bottom) {
        isDragging = true;
        startX = x;
        startY = y;
    }
}

function handleMove(x, y) {
    if (!isDragging || !currentObj) return;

    // 指の移動距離を計算
    const dist = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));

    // しきい値を超えたら「引き出しモード」へ移行
    if (dist > DRAG_THRESHOLD || hasMovedOut) {
        if (!hasMovedOut) {
            hasMovedOut = true;
            currentObj.render.opacity = 1;
            if (previewObj) previewObj.render.opacity = 0;
        }
        const xClamped = Math.max(30, Math.min(width - 30, x));
        Body.setPosition(currentObj, { x: xClamped, y: DROP_Y_LINE });
    }
}

function handleEnd() {
    if (!isDragging || !currentObj) return;
    isDragging = false;

    if (!hasMovedOut) {
        // しきい値以下ならタップ（回転）とみなす
        currentRotation += Math.PI / 2;
        Body.setAngle(currentObj, currentRotation);
        Body.setAngle(previewObj, currentRotation);
    } else {
        // フィールドでの落下
        Body.setStatic(currentObj, false);
        score += currentObj.scoreValue;
        document.getElementById('scoreVal').innerText = score;
        currentObj = null;
        setTimeout(spawnNext, 1000);
    }
}

// リスナー
window.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
window.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
window.addEventListener('mouseup', handleEnd);
window.addEventListener('touchstart', (e) => handleStart(e.touches[0].clientX, e.touches[0].clientY), {passive:false});
window.addEventListener('touchmove', (e) => handleMove(e.touches[0].clientX, e.touches[0].clientY), {passive:false});
window.addEventListener('touchend', handleEnd);

Events.on(engine, 'afterUpdate', () => {
    Composite.allBodies(engine.world).forEach(body => {
        if (body.position.y > height && !body.isStatic) {
            isGameOver = true;
            document.getElementById('msg').innerText = "GAME OVER";
        }
    });
});

Render.run(render);
Render.run(previewRender);
Runner.run(Runner.create(), engine);
spawnNext();
</script>
</body>
</html>
